#pragma once
#include "test.h"

extern int partyNum;
extern sci::NetIO *io;
extern sci::OTPack<sci::NetIO> *otpack;
extern MillionaireProtocol<sci::NetIO> *mill;

void testShareRec(){
    cout<<"####################################################################"<<endl;
    size_t size =5;
    int32_t bw=4;
    RSSVectorMyType a(size);
    vector<myType> data(size, 0), res(size, 0);
    print_vector(data, "data generated:");

    cout<<"/*************** test Arithmetic Share ***************/\n"<<endl;
    getAShares(a, data, bw);
    print_RSSVectorMyType(a, "data A shared:");
    getAReconstruct(a, res, size, "test Arithmetic rec",true, bw);

    cout<<"/*************** test Boolean Share ***************/\n"<<endl;
    getBShares(a,data, bw);
    print_RSSVectorMyType(a, "data A shared:");
    getBReconstruct(a, res, size, "test Boolean rec",true, bw);

    cout<<"/*************** test Reconstruct 3-out-of-3 ***************/\n"<<endl;
    if(partyNum == PARTY_A){
        getRandomNum(data, bw);
        print_vector(data, "data generated by Party_A");
    }
    if(partyNum == PARTY_B){
        getRandomNum(data, bw);
        print_vector(data, "data generated by Party_B");
    }
    if(partyNum == PARTY_C){
        getRandomNum(data, bw);
        print_vector(data, "data generated by Party_C");
    }
    getAReconstruct3in3(data, res, size, "res 3in3", bw, true);
    cout<<"####################################################################"<<endl;

}

void testTruncate(){
    cout<<"####################################################################"<<endl;
    size_t size = 5;
    int32_t bw = 4, power = 2;
    RSSVectorMyType a(size);
    vector<myType> data(size, 15), res(size, 0);

    print_vector(data, "the data generated: \n");
    getAShares(a, data, bw);
    print_RSSVectorMyType(a, "shared data:\n");

    getTruncate(a, bw, power);
    print_RSSVectorMyType(a, "truncated shared data:\n");
    getAReconstruct(a, data, size, "reconstructed truncated data (truncate may have error < 1ULP): \n", true, bw);
    cout<<"####################################################################"<<endl;
}

void testWrap3_uv(){
    cout<<"####################################################################"<<endl;
    size_t size = 1;
    int32_t bw = 4;
    RSSVectorMyType a(size);
    vector<myType> data(size, 0), res(size, 0);
    vector<uint8_t> u(size,0), v(size, 0), tmp(size, 0);

    print_vector(data, "\nthe origin vector before sharing:");
    getAShares(a, data, bw);
    print_RSSVectorMyType(a, "\nshared data:");

    wrap3_uv(a, u, v, size, bw);
    
    print_vector(u, "\nthe wrap value of u:");
    print_vector(v, "\nthe wrap value of v:");

    /* Eg. 某次运行结果：data=0=(10,3,3), u=wrap(3,3,bw=4)=0公开的， v=1=(0,0,1)是布尔共享的*/
    // addVectors(u, v, tmp, size);
    // print_vector(tmp, "\nsum of u and v:");
    cout<<"####################################################################"<<endl;

}

void testMultiplexer(){
// multiplexer(vector<uint8_t> select, vector<uint64_t> x, vector<uint64_t> y, int32_t size, int32_t bw_x, int32_t bw_y)
    cout<<"####################################################################"<<endl;
    size_t size = 1;
    int32_t bw = 4;
    vector<myType> data(size, 5), res(size, 0);
    vector<uint8_t>  sel(size, 0);
    for (int i = 0; i < size; ++i){
        if(partyNum == PARTY_B){
            sel[i]=1;
        }
    }
    print_vector(data, "the origin data vector:");
    print_vector(sel, "the select bit vector:");
    multiplexer(sel, data, res, size, bw, bw);
    print_vector(res, "result of multiplexer:");
    cout<<"####################################################################"<<endl;
}

void testMultVector(){
    cout<<"####################################################################"<<endl;
    size_t size = 1;
    int32_t bw = 4, bw_C = 8;
    vector<myType> data_a(size, 5), data_b(size, 2), res_clear(size, 0), res_rec(size, 0);
    RSSVectorMyType share_a(size), share_b(size), share_res(size);
    print_vector(data_a, "\na in cleartext:");
    print_vector(data_b, "\nb in cleartext:");

    getAShares(share_a, data_a, bw);
    getAShares(share_b, data_b, bw);
    print_RSSVectorMyType(share_a, "\nshared a:");
    print_RSSVectorMyType(share_b, "\nshared b:");
    
    vectorMult_nu_cleartext(data_a, data_b, res_clear, bw, bw, bw_C, size);
    vectorMult_nu(share_a, share_b, share_res, bw, bw, bw_C, size);
    print_RSSVectorMyType(share_res, "\nthe product in shared form:");
    print_vector(res_clear, "\nthe product in cleartext:");

    getAReconstruct(share_res, res_rec, size, "\nreconstruct the product:", true, bw_C);
    cout<<"####################################################################"<<endl;
}

void testDotProduct(){
    cout<<"####################################################################"<<endl;
    size_t size = 1;
    int32_t bw = 4, bw_C = 8;
    vector<myType> data_a(size, 5), data_b(size, 2), res_clear(size, 0);
    uint64_t res = 0, res_rec = 0;
    RSSVectorMyType share_a(size), share_b(size);
    RSSMyType share_res(make_pair(0, 0));
    print_vector(data_a, "\na in cleartext:");
    print_vector(data_b, "\nb in cleartext:");

    getAShares(share_a, data_a, bw);
    getAShares(share_b, data_b, bw);
    // print_RSSVectorMyType(share_a, "\nshared a:");
    // print_RSSVectorMyType(share_b, "\nshared b:");

    vectorMult_nu_cleartext(data_a, data_b, res_clear, bw, bw, bw_C, size);
    for (int i = 0; i < size; i++)
        res += res_clear[i];
    
    dotProduct(share_a, share_b, share_res, bw, bw, bw_C, size);
    cout<<"share_res[0], [1]: "<<share_res.first<<", "<<share_res.second<<endl;
    cout<<"\nthe dot product in cleartext: " << res <<endl;

    getAReconstructOne(share_res, res_rec, "\nthe product reconstructed:", true, bw_C);
    cout<<"####################################################################"<<endl;

}

void testB2AVector(){
    cout<<"####################################################################"<<endl;
    size_t size = 1;
    int32_t bw = 4, bw_C = 8;
    vector<smallType> data_a(size, 15), share_a(size), res_rec(size, 0);
    vector<myType> b2a_share_a(size, 0), share_res(size, 0);

    getBShares3in3(share_a, data_a, bw);
    print_vector(share_a, "\nBshared a:");

    B2A_vector(share_a, b2a_share_a, bw, bw, size);
    print_vector(b2a_share_a, "\nb2a_share_a (a shares in A, 3in3):");

    print_vector(data_a, "\na in cleartext:");
    getAReconstruct3in3(b2a_share_a, share_res, size, "\nreconstruct the b2a result", bw, true);

    cout<<"********** bw 不变**************"<<endl;
    //关于位宽变化之后只算原位宽值正确而带上高位值就不正确了这件事
    cout<<"********** bw 变 **************"<<endl;
    B2A_vector(share_a, b2a_share_a,bw, bw_C, size);
    print_vector(b2a_share_a, "\nb2a_share_a (a shares in A, 3in3):");

    print_vector(data_a, "\na in cleartext:");
    getAReconstruct3in3(b2a_share_a, share_res, size, "\nAreconstruct the b2a result", bw_C, true);

    cout<<"####################################################################"<<endl;

}

void testZ_extend(){
    cout<<"####################################################################"<<endl;
    size_t size =5;
    int32_t bw=4;
    RSSVectorMyType a(size), a_extend(size);
    vector<myType> data(size, 5), rec(size, 0);
    print_vector(data, "data in cleartext:");

    cout<<"/*************** test z_extend ***************/\n"<<endl;
    getAShares(a, data, bw);
    print_RSSVectorMyType(a, "data A shared:");
    z_extend(a, a_extend, bw, bw+4, size);
    print_RSSVectorMyType(a_extend, "data A extended shared:");
    getAReconstruct(a_extend, rec, size, "test A z_extend",true, bw);


    cout<<"####################################################################"<<endl;
}

void testMatMult(){
    cout<<"####################################################################"<<endl;
    size_t rows = 2, common_dim =3, columns =2;
    // size_t rows = 1, common_dim =3, columns =1;
    // size_t rows = 1, common_dim =1, columns =1;

    int32_t bw_A = 2, bw_B = 2, bw_C = 4;
    vector<myType> data_a(rows * common_dim, 1), data_b(common_dim * columns, 1), res_rec(rows * columns, 0);
    print_vector(data_a, "\na in cleartext:");
    print_vector(data_b, "\nb in cleartext:");

    RSSVectorMyType share_a(rows * common_dim), share_b(common_dim * columns), share_res(rows * columns);

    getAShares(share_a, data_a, bw_A);
    getAShares(share_b, data_b, bw_B);
    print_RSSVectorMyType(share_a, "\nshared a:");
    print_RSSVectorMyType(share_b, "\nshared b:"); 

    cout<<"\nbefore matMult:";
    matMult(share_a, share_b, share_res, rows, common_dim, columns, bw_A, bw_B, bw_C);
    cout<<"\nafter matMult:";

    print_RSSVectorMyType(share_res, "\nshared results: xxx.first, xxx.second");

    getAReconstruct(share_res, res_rec, rows*columns, "the reconstructed result of matrix multiplication\n(right result should be a matrix_2*2, with value all =3, bw_C=2+2+2=6)\n", true, bw_C);
    // getAReconstruct(share_res, res_rec, rows*columns, "the reconstructed result of matrix multiplication\n(right result should be a matrix_1*1, with value =1, bw_C=1+1+1=3)\n", true, bw_C);

    cout<<"bw_C: "<<bw_C<<endl;

    cout<<"####################################################################"<<endl;

}


